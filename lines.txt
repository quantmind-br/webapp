     1	#!/bin/bash
     2	
     3	# Standard icon path for better compatibility (e.g. nwg-dock)
     4	ICON_DIR="$HOME/.local/share/icons/hicolor/128x128/apps"
     5	DESKTOP_DIR="$HOME/.local/share/applications/"
     6	
     7	# Function to launch the web app
     8	run_app() {
     9	  local APP_URL="$1"
    10	  shift
    11	  
    12	  if [[ -z "$APP_URL" ]]; then
    13	    echo "Error: No URL provided."
    14	    exit 1
    15	  fi
    16	  
    17	  local BROWSER
    18	  BROWSER=$(xdg-settings get default-web-browser)
    19	
    20	  case $BROWSER in
    21	    google-chrome* | brave-browser* | microsoft-edge* | opera* | vivaldi* | helium-browser*) ;;
    22	    *) BROWSER="chromium.desktop" ;;
    23	  esac
    24	
    25	  # Resolve browser executable
    26	  local BROWSER_EXEC
    27	  # Try to find the Exec path from standard locations
    28	  # Extract only the command part (before first space)
    29	  BROWSER_EXEC=$(sed -n 's/^Exec=\([^ ]*\).*/\1/p' \
    30	      "$HOME/.local/share/applications/$BROWSER" \
    31	      "$HOME/.nix-profile/share/applications/$BROWSER" \
    32	      "/usr/share/applications/$BROWSER" \
    33	      2>/dev/null | head -1)
    34	
    35	  if [[ -z "$BROWSER_EXEC" ]]; then
    36	     # Fallback for when detection fails
    37	     if command -v chromium &>/dev/null; then
    38	        BROWSER_EXEC="chromium"
    39	     elif command -v google-chrome &>/dev/null; then
    40	        BROWSER_EXEC="google-chrome"
    41	     else
    42	        echo "Error: Could not detect a compatible browser (Chromium-based)."
    43	        exit 1
    44	     fi
    45	  fi
    46	  
    47	  # Use setsid and uwsm-app if available, otherwise just run
    48	  if command -v uwsm-app &>/dev/null; then
    49	      exec setsid uwsm-app -- "$BROWSER_EXEC" --app="$APP_URL" "$@"
    50	  else
    51	      exec "$BROWSER_EXEC" --app="$APP_URL" "$@"
    52	  fi
    53	}
    54	
    55	# Function to install a new webapp
    56	install_webapp() {
    57	  local APP_NAME APP_URL ICON_REF CUSTOM_EXEC MIME_TYPES INTERACTIVE
    58	  
    59	  if [[ $# -ge 3 ]]; then
    60	    APP_NAME="$1"
    61	    APP_URL="$2"
    62	    ICON_REF="$3"
    63	    CUSTOM_EXEC="$4"
    64	    MIME_TYPES="$5"
    65	    INTERACTIVE=false
    66	  else
    67	    echo -e "\e[32mLet's create a new web app you can start with the app launcher.\e[0m\n"
    68	    INTERACTIVE=true
    69	
    70	    APP_NAME=$(gum input --prompt "Name> " --placeholder "My favorite web app")
    71	    [[ -z "$APP_NAME" ]] && echo "Installation cancelled." && return
    72	
    73	    APP_URL=$(gum input --prompt "URL> " --placeholder "https://example.com")
    74	    [[ -z "$APP_URL" ]] && echo "Installation cancelled." && return
    75	
    76	    ICON_REF=$(gum input --prompt "Icon URL> " --placeholder "See https://dashboardicons.com (must use PNG!)")
    77	    [[ -z "$ICON_REF" ]] && echo "Installation cancelled." && return
    78	
    79	    # Ask if user wants custom exec or mime types
    80	    ADVANCED=$(gum choose --header "Add advanced options?" "No" "Yes")
    81	
    82	    if [[ "$ADVANCED" == "Yes" ]]; then
    83	      CUSTOM_EXEC=$(gum input --prompt "Custom Exec (optional)> " --placeholder "Leave empty for default")
    84	      MIME_TYPES=$(gum input --prompt "MIME types (optional)> " --placeholder "e.g., x-scheme-handler/mailto")
    85	    fi
    86	  fi
    87	
    88	  # Sanitize filename
    89	  SAFE_FILENAME=$(echo "$APP_NAME" | tr -dc '[:alnum:]\-\ _ ' | tr ' ' '_')
    90	  [[ -z "$SAFE_FILENAME" ]] && SAFE_FILENAME="webapp_$(date +%s)"
    91	
    92	  # Create icon directory
    93	  mkdir -p "$ICON_DIR"
    94	
    95	  # Handle icon download/copy
    96	  if [[ $ICON_REF =~ ^https?:// ]]; then
    97	    ICON_PATH="$ICON_DIR/$SAFE_FILENAME.png"
    98	    if curl -sL -o "$ICON_PATH" "$ICON_REF"; then
    99	      echo "Icon downloaded successfully."
   100	    else
   101	      echo "Error: Failed to download icon."
   102	      return 1
   103	    fi
   104	  elif [[ -f "$ICON_REF" ]]; then
   105	    ICON_PATH="$ICON_DIR/$SAFE_FILENAME.png"
   106	    if cp "$ICON_REF" "$ICON_PATH"; then
   107	      echo "Icon copied successfully from local path."
   108	    else
   109	      echo "Error: Failed to copy icon from $ICON_REF"
   110	      return 1
   111	    fi
   112	  else
   113	    # Check existing icon reference
   114	    if [[ -f "$ICON_DIR/$ICON_REF" ]]; then
   115	        ICON_PATH="$ICON_DIR/$ICON_REF"
   116	    else
   117	      echo "Error: Icon file not found at $ICON_REF"
   118	      return 1
   119	    fi
   120	  fi
   121	  
   122	  # For .desktop file, we use just the name (without extension) if it's in a standard path
   123	  ICON_NAME_ONLY="$SAFE_FILENAME"
   124	
   125	  # Determine execution command
   126	  if [[ -n $CUSTOM_EXEC ]]; then
   127	    EXEC_COMMAND="$CUSTOM_EXEC"
   128	  else
   129	    # Use this script itself to launch
   130	    # Resolve absolute path to self if not in PATH
   131	    if command -v webapp &>/dev/null; then
   132	       LAUNCHER_CMD="webapp"
   133	    else
   134	       LAUNCHER_CMD=$(realpath "$0")
   135	    fi
   136	    
   137	    EXEC_COMMAND="$LAUNCHER_CMD run $APP_URL $APP_NAME"
   138	  fi
   139	
   140	  # Generate StartupWMClass for Chromium webapps
   141	  URL_WITHOUT_PROTOCOL=$(echo "$APP_URL" | sed -E 's|https?://||')
   142	  if [[ "$URL_WITHOUT_PROTOCOL" =~ /$ ]]; then
   143	    URL_FORMATTED=$(echo "$URL_WITHOUT_PROTOCOL" | sed -E 's|/$|__|' | sed -E 's|/|__|g')
   144	  else
   145	    URL_FORMATTED=$(echo "$URL_WITHOUT_PROTOCOL" | sed -E 's|/|__|g')
   146	  fi
   147	  STARTUP_WM_CLASS="chrome-${URL_FORMATTED}-Default"
   148	
   149	  # Create application .desktop file
   150	  # Use STARTUP_WM_CLASS as filename for nwg-dock compatibility
   151	  DESKTOP_FILE="$DESKTOP_DIR/$STARTUP_WM_CLASS.desktop"
   152	
   153	  cat >"$DESKTOP_FILE" <<EOF
   154	[Desktop Entry]
   155	Version=1.0
   156	Name=$APP_NAME
   157	Comment=$APP_NAME
   158	Exec=$EXEC_COMMAND
   159	Terminal=false
   160	Type=Application
   161	Icon=$ICON_NAME_ONLY
   162	StartupWMClass=$STARTUP_WM_CLASS
   163	StartupNotify=true
   164	X-WebApp-Manager=true
   165	EOF
   166	
   167	  # Add mime types if provided
   168	  if [[ -n $MIME_TYPES ]]; then
   169	    echo "MimeType=$MIME_TYPES" >>"$DESKTOP_FILE"
   170	  fi
   171	
   172	  chmod +x "$DESKTOP_FILE"
   173	
   174	  # Update desktop database
   175	  update-desktop-database ~/.local/share/applications/ 2>/dev/null
   176	  
   177	  # Update icon cache if possible
   178	  if command -v gtk-update-icon-cache &>/dev/null; then
   179	     if [[ ! -f "$HOME/.local/share/icons/hicolor/index.theme" ]]; then
   180	        mkdir -p "$HOME/.local/share/icons/hicolor"
   181	        echo -e "[Icon Theme]\nName=Hicolor\nComment=Default fallback theme\nDirectories=128x128/apps" > "$HOME/.local/share/icons/hicolor/index.theme"
   182	     fi
   183	     gtk-update-icon-cache "$HOME/.local/share/icons/hicolor" &>/dev/null
   184	  fi
   185	
   186	  # Update waybar app_ids-mapping
   187	  WAYBAR_MODULES="$HOME/.config/waybar/modules.json"
   188	  if [[ -f "$WAYBAR_MODULES" ]]; then
   189	    if command -v jq &>/dev/null; then
   190	      TMP_JSON=$(mktemp)
   191	      if jq --arg app "$APP_NAME" --arg class "$STARTUP_WM_CLASS" \
   192	         '."app_ids-mapping"[$class] = $app' "$WAYBAR_MODULES" > "$TMP_JSON"; then
   193	        mv "$TMP_JSON" "$WAYBAR_MODULES"
   194	        echo "Waybar configuration updated."
   195	      else
   196	        rm "$TMP_JSON"
   197	        echo "Error updating Waybar configuration with jq."
   198	      fi
   199	    else
   200	      echo "Warning: 'jq' not found. Skipping Waybar configuration update to prevent corruption."
   201	    fi
   202	  fi
   203	
   204	  if [[ "$INTERACTIVE" == "true" ]]; then
   205	    echo -e "\n\e[32mâœ“ $APP_NAME installed successfully!\e[0m"
   206	    echo -e "You can now find it using the app launcher (SUPER + SPACE)"
   207	    echo -e "Restart waybar to see the icon in the taskbar: ~/.config/waybar/launch.sh\n"
   208	  else
   209	    echo "âœ“ Installed $APP_NAME"
   210	  fi
   211	}
   212	
   213	# Function to launch a webapp (from menu)
   214	launch_webapp() {
   215	  declare -a WEB_APPS
   216	  declare -a WEB_APP_FILES
   217	
   218	  while IFS= read -r -d '' file; do
   219	    # Only look for files managed by this new version
   220	    if grep -q '^X-WebApp-Manager=true' "$file" || \
   221	       grep -q '^Exec=.*webapp[[:space:]]run.*' "$file"; then
   222	      APP_NAME=$(grep '^Name=' "$file" | sed 's/^Name=//')
   223	      FILENAME=$(basename "$file")
   224	      WEB_APPS+=("$APP_NAME [$FILENAME]")
   225	      WEB_APP_FILES+=("$file")
   226	    fi
   227	  done < <(find "$DESKTOP_DIR" -name '*.desktop' -print0)
   228	
   229	  if [[ ${#WEB_APPS[@]} -eq 0 ]]; then
   230	    echo "No web apps installed."
   231	    return 1
   232	  fi
   233	
   234	  IFS=$'\n' SORTED_INDICES=($( 
   235	    for i in "${!WEB_APPS[@]}"; do
   236	      echo "$i|${WEB_APPS[$i]}"
   237	    done | sort -t'|' -k2 | cut -d'|' -f1
   238	  ))
   239	  unset IFS
   240	
   241	  declare -a SORTED_APPS
   242	  for idx in "${SORTED_INDICES[@]}"; do
   243	    SORTED_APPS+=("${WEB_APPS[$idx]}")
   244	  done
   245	
   246	  SELECTED=$(gum choose --header "Select web app to launch..." "${SORTED_APPS[@]}")
   247	
   248	  if [[ -n "$SELECTED" ]]; then
   249	    for i in "${!WEB_APPS[@]}"; do
   250	      if [[ "${WEB_APPS[$i]}" == "$SELECTED" ]]; then
   251	        FILE="${WEB_APP_FILES[$i]}"
   252	        break
   253	      fi
   254	    done
   255	
   256	    APP_NAME_ONLY=$(grep '^Name=' "$FILE" | sed 's/^Name=//')
   257	    echo "Launching $APP_NAME_ONLY..."
   258	    gtk-launch "$(basename "$FILE")" & 
   259	    disown
   260	  fi
   261	}
   262	
   263	# Function to list webapps
   264	list_webapps() {
   265	  declare -a WEB_APPS
   266	
   267	  while IFS= read -r -d '' file; do
   268	    if grep -q '^X-WebApp-Manager=true' "$file" || \
   269	       grep -q '^Exec=.*webapp[[:space:]]run.*' "$file"; then
   270	      WEB_APPS+=("$file")
   271	    fi
   272	  done < <(find "$DESKTOP_DIR" -name '*.desktop' -print0)
   273	
   274	  if [[ ${#WEB_APPS[@]} -eq 0 ]]; then
   275	    echo "No web apps installed."
   276	    return 0
   277	  fi
   278	
   279	  IFS=$'\n' SORTED_WEB_APPS=($(sort <<<"${WEB_APPS[*]}"))
   280	  unset IFS
   281	
   282	  echo -e "\e[1;36mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
   283	  echo -e "â•‘                    Installed Web Apps                          â•‘"
   284	  echo -e "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\e[0m\n"
   285	
   286	  for file in "${SORTED_WEB_APPS[@]}"; do
   287	    APP_NAME=$(grep '^Name=' "$file" | sed 's/^Name=//')
   288	    EXEC_LINE=$(grep '^Exec=' "$file" | sed 's/^Exec=//')
   289	    ICON=$(grep '^Icon=' "$file" | sed 's/^Icon=//')
   290	
   291	    if [[ $EXEC_LINE =~ webapp[[:space:]]run[[:space:]]+([^[:space:]"]+) ]]; then
   292	      URL="${BASH_REMATCH[1]}"
   293	    else
   294	      URL="(custom/unknown)"
   295	    fi
   296	
   297	    if [[ -f "$ICON" ]]; then
   298	      ICON_STATUS="\e[32mâœ“\e[0m"
   299	      ICON_COLOR="\e[32m"
   300	    else
   301	      ICON_STATUS="\e[31mâœ—\e[0m"
   302	      ICON_COLOR="\e[31m"
   303	    fi
   304	
   305	    echo -e "\e[1;33mâ–¸\e[0m \e[1;97m$APP_NAME\e[0m"
   306	    echo -e "  \e[36mðŸŒ URL:\e[0m  \e[94m$URL\e[0m"
   307	    echo -e "  \e[36mðŸ–¼ï¸  Icon:\e[0m  $ICON_STATUS $ICON_COLOR$ICON\e[0m"
   308	    echo -e "  \e[90mâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\e[0m"
   309	  done
   310	
   311	  echo -e "\n\e[1;32mðŸ“Š Total: ${#SORTED_WEB_APPS[@]} web app(s)\e[0m"
   312	  echo ""
   313	}
   314	
   315	# Function to remove webapps
   316	remove_webapp() {
   317	  declare -a WEB_APPS
   318	  declare -a WEB_APP_FILES
   319	
   320	  while IFS= read -r -d '' file; do
   321	    if grep -q '^X-WebApp-Manager=true' "$file" || \
   322	       grep -q '^Exec=.*webapp[[:space:]]run.*' "$file"; then
   323	      APP_NAME=$(grep '^Name=' "$file" | sed 's/^Name=//')
   324	      FILENAME=$(basename "$file")
   325	      WEB_APPS+=("$APP_NAME [$FILENAME]")
   326	      WEB_APP_FILES+=("$file")
   327	    fi
   328	  done < <(find "$DESKTOP_DIR" -name '*.desktop' -print0)
   329	
   330	  if [[ ${#WEB_APPS[@]} -eq 0 ]]; then
   331	    echo "No web apps to remove."
   332	    return 1
   333	  fi
   334	
   335	  IFS=$'\n' SORTED_INDICES=($( 
   336	    for i in "${!WEB_APPS[@]}"; do
   337	      echo "$i|${WEB_APPS[$i]}"
   338	    done | sort -t'|' -k2 | cut -d'|' -f1
   339	  ))
   340	  unset IFS
   341	
   342	  declare -a SORTED_OPTS
   343	  for idx in "${SORTED_INDICES[@]}"; do
   344	    SORTED_OPTS+=("${WEB_APPS[$idx]}")
   345	  done
   346	
   347	  SELECTED_STRING=$(gum choose --no-limit --header "Select web app(s) to remove..." --selected-prefix="âœ— " "${SORTED_OPTS[@]}")
   348	
   349	  if [[ -z "$SELECTED_STRING" ]]; then
   350	    echo "No web apps selected."
   351	    return 0
   352	  fi
   353	
   354	  declare -a TARGET_FILES
   355	  declare -a TARGET_NAMES
   356	  
   357	  IFS=$'\n'
   358	  for selection in $SELECTED_STRING; do
   359	    for i in "${!WEB_APPS[@]}"; do
   360	      if [[ "${WEB_APPS[$i]}" == "$selection" ]]; then
   361	        TARGET_FILES+=("${WEB_APP_FILES[$i]}")
   362	        NAME=$(grep '^Name=' "${WEB_APP_FILES[$i]}" | sed 's/^Name=//')
   363	        TARGET_NAMES+=("$NAME")
   364	        break
   365	      fi
   366	    done
   367	  done
   368	  unset IFS
   369	
   370	  CONFIRM=$(gum choose --header "Remove ${#TARGET_FILES[@]} web app(s)?" "No" "Yes")
   371	
   372	  if [[ "$CONFIRM" == "Yes" ]]; then
   373	    for i in "${!TARGET_FILES[@]}"; do
   374	      FILE="${TARGET_FILES[$i]}"
   375	      APP_NAME="${TARGET_NAMES[$i]}"
   376	      
   377	      ICON_PATH=$(grep '^Icon=' "$FILE" | sed 's/^Icon=//')
   378	      
   379	      rm -f "$FILE"
   380	      echo "âœ“ Removed desktop file for $APP_NAME"
   381	      
   382	      if [[ "$ICON_PATH" == "$ICON_DIR"* && -f "$ICON_PATH" ]]; then
   383	        rm -f "$ICON_PATH"
   384	        echo "âœ“ Removed icon: $ICON_PATH"
   385	      elif [[ -n "$ICON_PATH" && -f "$ICON_PATH" ]]; then
   386	        echo "â„¹ Skipped external icon: $ICON_PATH"
   387	      fi
   388	    done
   389	
   390	    update-desktop-database ~/.local/share/applications/ 2>/dev/null
   391	    echo -e "\n\e[32mRemoval completed!\e[0m\n"
   392	  else
   393	    echo "Removal cancelled."
   394	  fi
   395	}
   396	
   397	# Function to backup webapps
   398	backup_webapp() {
   399	  if ! command -v jq &>/dev/null; then
   400	    echo "Error: 'jq' is required for backup/restore but not installed."
   401	    return 1
   402	  fi
   403	  if ! command -v git &>/dev/null; then
   404	    echo "Error: 'git' is required for backup/restore but not installed."
   405	    return 1
   406	  fi
   407	
   408	  local CONFIG_DIR="$HOME/.config/webapp-manager"
   409	  local REPO_DIR="$CONFIG_DIR/backup-repo"
   410	  local CONFIG_FILE="$CONFIG_DIR/config"
   411	  
   412	  mkdir -p "$CONFIG_DIR"
   413	
   414	  local REPO_URL=""
   415	  if [[ -f "$CONFIG_FILE" ]]; then
   416	    source "$CONFIG_FILE"
   417	  fi
   418	
   419	  if [[ -z "$REPO_URL" ]]; then
   420	    echo -e "\e[32mSet up Web App Backup\e[0m"
   421	    REPO_URL=$(gum input --prompt "GitHub Repo URL> " --placeholder "https://github.com/username/my-webapps-backup.git")
   422	    if [[ -z "$REPO_URL" ]]; then
   423	      echo "Backup cancelled."
   424	      return 1
   425	    fi
   426	    echo "REPO_URL=\"$REPO_URL\"" > "$CONFIG_FILE"
   427	  fi
   428	
   429	  if [[ ! -d "$REPO_DIR/.git" ]]; then
   430	    echo "Cloning backup repository..."
   431	    rm -rf "$REPO_DIR"
   432	    git clone "$REPO_URL" "$REPO_DIR" || { echo "Error cloning repository"; return 1; }
   433	  else
   434	    echo "Updating backup repository..."
   435	    cd "$REPO_DIR" || return 1
   436	    if ! git pull 2>/dev/null; then
   437	       echo "Warning: git pull failed. This is expected if the repository is empty or has no upstream branch yet."
   438	    fi
   439	  fi
   440	
   441	  cd "$REPO_DIR" || return 1
   442	  mkdir -p icons
   443	
   444	  echo "Scanning installed web apps..."
   445	  declare -a WEB_APP_JSONS=()
   446	
   447	  while IFS= read -r -d '' file; do
   448	    if grep -q '^X-WebApp-Manager=true' "$file" || \
   449	       grep -q '^Exec=.*webapp[[:space:]]run.*' "$file"; then
   450	       
   451	      APP_NAME=$(grep '^Name=' "$file" | sed 's/^Name=//')
   452	      EXEC_LINE=$(grep '^Exec=' "$file" | sed 's/^Exec=//')
   453	      ICON_PATH=$(grep '^Icon=' "$file" | sed 's/^Icon=//')
   454	      MIME_TYPES=$(grep '^MimeType=' "$file" | sed 's/^MimeType=//')
   455	      
   456	      local REGEX_RUN='webapp[[:space:]]run[[:space:]]+([^[:space:]"]+)'
   457	
   458	      if [[ $EXEC_LINE =~ $REGEX_RUN ]]; then
   459	        URL="${BASH_REMATCH[1]}"
   460	        CUSTOM_EXEC=""
   461	      else
   462	        URL=""
   463	        CUSTOM_EXEC="$EXEC_LINE"
   464	      fi
   465	
   466	      ICON_FILENAME=""
   467	      if [[ -f "$ICON_PATH" ]]; then
   468	         ICON_FILENAME=$(basename "$ICON_PATH")
   469	         cp "$ICON_PATH" "icons/$ICON_FILENAME"
   470	      fi
   471	
   472	      JSON_OBJ=$(jq -n \
   473	                    --arg name "$APP_NAME" \
   474	                    --arg url "$URL" \
   475	                    --arg icon "$ICON_FILENAME" \
   476	                    --arg exec "$CUSTOM_EXEC" \
   477	                    --arg mime "$MIME_TYPES" \
   478	                    '{name: $name, url: $url, icon: $icon, custom_exec: $exec, mime_types: $mime}')
   479	      
   480	      WEB_APP_JSONS+=("$JSON_OBJ")
   481	      echo "  + Processed: $APP_NAME"
   482	    fi
   483	  done < <(find "$DESKTOP_DIR" -name '*.desktop' -print0)
   484	
   485	  echo "Writing manifest..."
   486	  printf '%s\n' "${WEB_APP_JSONS[@]}" | jq -s '.' > webapps.json
   487	
   488	  if [[ -n $(git status -s) ]]; then
   489	    
   490	    # Check/Set Git Identity if missing
   491	    if [[ -z $(git config user.email) ]]; then
   492	      echo "Git identity not set for backup repository."
   493	      GIT_EMAIL=$(gum input --prompt "Git Email> " --placeholder "you@example.com")
   494	      GIT_NAME=$(gum input --prompt "Git Name> " --placeholder "Your Name")
   495	      
   496	      if [[ -n "$GIT_EMAIL" && -n "$GIT_NAME" ]]; then
   497	        git config user.email "$GIT_EMAIL"
   498	        git config user.name "$GIT_NAME"
   499	      else
   500	        echo "Error: Git identity required for backup."
   501	        return 1
   502	      fi
   503	    fi
   504	
   505	    echo "Pushing changes to GitHub..."
   506	    git add .
   507	    git commit -m "Update webapps backup: $(date)"
   508	    git push -u origin HEAD || { echo "Error pushing to GitHub"; return 1; }
   509	    echo -e "\n\e[32mâœ“ Backup successful!\e[0m"
   510	  else
   511	    echo -e "\n\e[32mâœ“ No changes to back up.\e[0m"
   512	  fi
   513	  
   514	  # Return to original dir
   515	  cd - >/dev/null
   516	}
   517	
   518	# Function to restore webapps
   519	restore_webapp() {
   520	  # Dependencies check
   521	  if ! command -v jq &>/dev/null; then
   522	    echo "Error: 'jq' is required for backup/restore but not installed."
   523	    return 1
   524	  fi
   525	  if ! command -v git &>/dev/null; then
   526	    echo "Error: 'git' is required for backup/restore but not installed."
   527	    return 1
   528	  fi
   529	
   530	  local CONFIG_DIR="$HOME/.config/webapp-manager"
   531	  local REPO_DIR="$CONFIG_DIR/backup-repo"
   532	  local CONFIG_FILE="$CONFIG_DIR/config"
   533	
   534	  mkdir -p "$CONFIG_DIR"
   535	
   536	  # Get Repo URL
   537	  local REPO_URL=""
   538	  if [[ -f "$CONFIG_FILE" ]]; then
   539	    source "$CONFIG_FILE"
   540	  fi
   541	
   542	  if [[ -z "$REPO_URL" ]]; then
   543	    echo -e "\e[32mRestore Web Apps\e[0m"
   544	    REPO_URL=$(gum input --prompt "GitHub Repo URL> " --placeholder "https://github.com/username/my-webapps-backup.git")
   545	    if [[ -z "$REPO_URL" ]]; then
   546	      echo "Restore cancelled."
   547	      return 1
   548	    fi
   549	    echo "REPO_URL=\"$REPO_URL\"" > "$CONFIG_FILE"
   550	  fi
   551	
   552	  # Initialize/Update Repo
   553	  if [[ ! -d "$REPO_DIR/.git" ]]; then
   554	    echo "Cloning backup repository..."
   555	    rm -rf "$REPO_DIR"
   556	    git clone "$REPO_URL" "$REPO_DIR" || { echo "Error cloning repository"; return 1; }
   557	  else
   558	    echo "Updating backup repository..."
   559	    cd "$REPO_DIR" || return 1
   560	    git pull || echo "Warning: git pull failed. Using local copy."
   561	  fi
   562	
   563	  local MANIFEST="$REPO_DIR/webapps.json"
   564	  if [[ ! -f "$MANIFEST" ]]; then
   565	    echo "Error: webapps.json not found in backup repository."
   566	    return 1
   567	  fi
   568	
   569	  echo "Restoring web apps..."
   570	
   571	  # Read manifest and iterate
   572	  jq -r '.[] | "\(.name)|\(.url)|\(.icon)|\(.custom_exec)|\(.mime_types)"' "$MANIFEST" | while IFS='|' read -r name url icon_file custom_exec mime_types; do
   573	    
   574	    # Check if already installed
   575	    local DESKTOP_FILE="$HOME/.local/share/applications/$name.desktop" 
   576	    
   577	    if [[ -f "$DESKTOP_FILE" ]]; then
   578	      echo "âš  Skipping '$name' (already installed)"
   579	      continue
   580	    fi
   581	
   582	    echo "Installing '$name'..."
   583	    
   584	    # Resolve icon path
   585	    local ICON_PATH=""
   586	    if [[ -n "$icon_file" && "$icon_file" != "null" ]]; then
   587	      ICON_PATH="$REPO_DIR/icons/$icon_file"
   588	    fi
   589	
   590	    # Handle cases where URL might be missing/null if it was a purely custom exec
   591	    if [[ "$url" == "null" ]]; then url=""; fi
   592	    if [[ "$custom_exec" == "null" ]]; then custom_exec=""; fi
   593	    if [[ "$mime_types" == "null" ]]; then mime_types=""; fi
   594	
   595	    # Call internal install function
   596	    install_webapp "$name" "$url" "$ICON_PATH" "$custom_exec" "$mime_types"
   597	
   598	  done
   599	
   600	  echo -e "\n\e[32mâœ“ Restore completed!\e[0m"
   601	  
   602	  # Return to original dir
   603	  cd - >/dev/null
   604	}
   605	
   606	# Main menu loop
   607	main_menu() {
   608	  while true; do
   609	    echo -e "\e[32mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
   610	    echo -e "â•‘       Web App Manager              â•‘"
   611	    echo -e "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\e[0m\n"
   612	
   613	    ACTION=$(gum choose --header "What would you like to do?" \
   614	      "Install new web app" \
   615	      "Launch web app" \
   616	      "List installed web apps" \
   617	      "Remove web app(s)" \
   618	      "Backup web apps" \
   619	      "Restore web apps" \
   620	      "Exit")
   621	
   622	    echo ""
   623	
   624	    case "$ACTION" in
   625	      "Install new web app")
   626	        install_webapp
   627	        ;; 
   628	      "Launch web app")
   629	        launch_webapp
   630	        ;; 
   631	      "List installed web apps")
   632	        list_webapps
   633	        ;; 
   634	      "Remove web app(s)")
   635	        remove_webapp
   636	        ;; 
   637	      "Backup web apps")
   638	        backup_webapp
   639	        ;; 
   640	      "Restore web apps")
   641	        restore_webapp
   642	        ;; 
   643	      "Exit")
   644	        echo "Goodbye!"
   645	        exit 0
   646	        ;; 
   647	      *)
   648	        echo "Invalid option."
   649	        ;; 
   650	    esac
   651	
   652	    echo ""
   653	    gum input --prompt "Press Enter to continue..." --placeholder "" >/dev/null
   654	    clear
   655	  done
   656	}
   657	
   658	
   659	# Main entry point with argument handling
   660	# Check for specific commands first
   661	if [[ "$1" == "run" ]]; then
   662	  shift
   663	  run_app "$@"
   664	  exit $?
   665	elif [[ "$1" == "install" ]]; then
   666	  shift
   667	  install_webapp "$@"
   668	  exit $?
   669	elif [[ "$1" == "list" ]]; then
   670	  list_webapps
   671	  exit $?
   672	elif [[ "$1" == "remove" ]]; then
   673	  remove_webapp
   674	  exit $?
   675	fi
   676	
   677	# Check if gum is installed
   678	if ! command -v gum &>/dev/null; then
   679	  echo "Error: 'gum' is required but not installed."
   680	  echo "Install it from: https://github.com/charmbracelet/gum"
   681	  exit 1
   682	fi
   683	
   684	# Run main menu
   685	main_menu